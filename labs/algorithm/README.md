# Overview

Different problems have different complexity based on who is solving them, and they might have more than one solution. Some solutions might be optimal, some might be using brute force, and some might be elegant. Some require active revision, some require remembering tricks always, and some require constant practice. So, it is important to categorise so that we can practice the one which requires more attention. The categorisation aims to do the same. Every algorithm has tags belonging to the following categories:


| ID	 | Aspect             | Description                                                                     |
|:----|:-------------------|:--------------------------------------------------------------------------------|
| 1   | Readiness          | Ability to author code in an acceptable format (not crude) at any point in time |
| 2   | Popularity         | Probability of being asked                                                      |
| 3   | Code Knowledge     | Knowledge of the code                                                           |
| 4   | Analysis Knowledge | Complexity of problem, includes an aspect of language knowledge                 |
| 5   | Strategy           | Mechanism to solve such problem to solve in 10 minutes                          |

**Readiness** can be one of the following values:

| Type  | Description                                                                |
|:------|:---------------------------------------------------------------------------|
| RUN   | Author can finish in 10 minutes including test cases.                      |
| WALK  | Author knows the technique, and can finish but takes more than 10 minutes. |
| CRAWL | Author takes more than 15 minutes to find the working solution             |

**Popularity** can be one of the following values:

| Type   | Description                                                       |
|:-------|:------------------------------------------------------------------|
| HIGH   | Very popular                                                      |
| MEDIUM | Average popular but expected to be asked in more than 50% chances |
| LOW    | Rare to be asked but MAANG has a high possibility                 |

**Code Knowledge** can be one of the following values:

| Type      | Description                                                    |
|:----------|:---------------------------------------------------------------|
| EXCELLENT | Author knows the technique                                     |
| OK        | Author knows the technique, but finds difficult in applying it |
| IMPROVE   | Author does not get a clue or remember after a few days        |

**Analysis Knowledge** can be one of the following values:

| Type      | Description                                                    |
|:----------|:---------------------------------------------------------------|
| EXCELLENT | Author knows the technique                                     |
| OK        | Author knows the technique, but finds difficult in applying it |
| UGLY      | Author does not get a clue or remember after a few days        |


**Strategy** can be one of the following values:

| Type     | Description                                                      |
|:---------|:-----------------------------------------------------------------|
| REFRESH  | Author occasionally to avoid complete practice                   |
| REVISE   | Author could write but revision is mandatory to be able to run   |
| MEMORISE | Author knows the technique, but find it difficult in applying it |
| UNSURE   | Author does not get a clue or remember after a few days          |


Let us use the following format:

Analysis =  Readiness | Popularity | Code Knowledge | Analysis Knowledge | Strategy 


# Algorithm groups

In this context, the task of categorizing algorithms into specific groups lacks a definitive approach due to the wide-ranging diversity of factors involved. The endeavor resembles the challenge of arranging a highly extensive and varied assortment. Conversely, should one choose not to engage in organization, the capacity to establish clear definitions, progress purposefully, and gauge advancement toward a particular objective diminishes. While one may engage in actions or progression regularly, the path taken remains obscure. Hence, the process of arranging elements in an orderly manner is intricate but indispensable. This particular section strives to accomplish this objective with utmost sincerity, leveraging the best available skills and comprehensive coverage.

1. TwoPointers
2. Matrix
   1. Traversal
   2. Sparse Matrix
3. Sliding Window
4. Subsets
5. Stacks
   1. Monotonic Stack
6. Linked List 
   1. In-place reversals 
   2. Hare and Tortoise
7. Binary Tree 
   1. BFS 
   2. DFS 
   3. Modified Binary Search
8. Heaps
   1. Heapify
   2. TOP-K Elements 
   3. Two Heaps 
   4. Priority Queue
9. Graph
    1. Topological Sort
10. Knapsack
11. Backtracking
12. Dynamic Programming
13. Sort
    1. Cyclic Sort
    2. Quick Sort
14. Merge
    * K-merge
15. Mathematical Techniques
    1. XOR
    2. Permutation and Combination
      

